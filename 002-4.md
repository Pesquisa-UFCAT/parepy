---
title: β index
layout: home
nav_order: 2
parent: Learning
---

<!--Don't delete this script-->
<script src = "https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id = "MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<!--Don't delete this script-->

<h1>Estimativa do índice de confiabilidade \(β\)</h1>

<p align = "justify">
Uma vez que o resultado direto da Simulação de Monte Carlo (SMC) é a estimativa da probabilidade de falha (\(\hat{p}_f\)), o índice de confiabilidade \(β\) pode ser determinado a partir desse valor, segundo a equação <a href="#eq1">(1)</a>.
</p>

<table border = "0" style = "width: 100%;">
  <tr>
    <td align = "left" style = "width: 95%;">\[\beta_{SMC}=\Phi ^{-1}(1-\hat{p}_f)\]</td>
    <td align = "right" style = "width: 5%;"><p id = "eq1">(1)</p></td>
  </tr>
</table>

<p align = "justify">
Levando em consideração que a confiança é o complemento da probabilidade de falha, juntamente com o pressuposto de que um modelo Gaussiano é admitido em sua estimativa, torna-se viável a elaboração da expressão delineada na equação <a href="#eq2">(2)</a>.
</p>

<table border = "0" style = "width: 100%;">
  <tr>
    <td align = "left" style = "width: 95%;">\[\hat{p}_f=\Phi (-\beta )\]</td>
    <td rowspam = "6" align = "right" style = "width: 5%;"><p id = "eq2">(2)</p></td>
  </tr>
   <tr>
    <td align = "left" style = "width: 95%;">\[\hat{p}_f=1-\Phi (\beta )\]</td>
  </tr>
  <tr>
    <td align = "left" style = "width: 95%;">\[\hat{p}_f=1-\int_{-\infty}^{\beta }\frac{1}{\sqrt{2\pi }}e^{-u^2/2}du\]</td>
  </tr>
  <tr>
    <td align = "left" style = "width: 95%;">\[\hat{p}_f=1-\left (\int_{-\infty}^{0}\frac{1}{\sqrt{2\pi}}e^{-u^2/2}du+\int_{0}^{\beta}\frac{1}{\sqrt{2\pi }}e^{-u^2/2}du  \right )\]</td>
  </tr>
  <tr>
    <td align = "left" style = "width: 95%;">\[\hat{p}_f=1-\left (0.5+\int_{0}^{\beta}\frac{1}{\sqrt{2\pi }}e^{-u^2/2}du  \right )\]</td>
  </tr>
  <tr>
    <td align = "left" style = "width: 95%;">\[\hat{p}_f=0.5-\int_{0}^{\beta }\frac{1}{\sqrt{2\pi}}e^{-u^2/2}du\]</td>
  </tr>
</table>

<p align = "justify">
A solução da integral contida na equação <a href="#eq2">(2)</a> não admite uma abordagem analítica, exigindo a aplicação de um método numérico de integração. Na obtenção da equação destinada à estimativa de \(β\), uma metodologia bastante eficaz é a de Gauss-Legendre, cuja formulação geral está expressa na equação <a href="#eq3">(3)</a>, onde \(k\) é o número de pontos de integração; \(t_i\) é a abscissa do ponto de integração \(i\) e \(w_i\) é o peso associado ao ponto de integração \(i\).
</p>

<table border = "0" style = "width: 100%;">
  <tr>
    <td align = "left" style = "width: 95%;">\[\int_{a}^{b}f(x)dx=\frac{b-a}{2}\int_{-1}^{1}f(t)dt\]</td>
    <td rowspam = "2" align = "right" style = "width: 5%;"><p id = "eq3">(3)</p></td>
  </tr>
   <tr>
    <td align = "left" style = "width: 95%;">\[I_k=\frac{b-a}{2}\sum_{i=1}^{k}w_if(x_i)\Rightarrow x_i=a+\frac{b-a}{2}(t_i+1)\]</td>
  </tr>
</table>

<p align = "justify">
Vale ressaltar que não é mérito deste texto formular os valores das abscissas \(t\) e dos pesos \(w\), uma vez que ambos podem ser obtidos em tabelas específicas disponíveis na literatura correspondente (ver Anexo A). Portanto, a título de esclarecimento, será deduzida a seguir a equação destinada à estimativa de \(β\), considerando dois pontos de integração (\(k=2\)). Neste contexto, as abscissas tabeladas \(t_1\) e \(t_2\) são fixadas em \(\pm 1/\sqrt{3}\), enquanto os pesos respectivos tabelados \(w_1\) e \(w_2\) são estabelecidos como 1.0. A equação <a href="#eq4">(4)</a> demonstra a construção da integral contida na <a href="#eq2">(2)</a> por meio do método de Gauss-Legendre.
</p>

<table border = "0" style = "width: 100%;">
  <tr>
    <td align = "left" style = "width: 95%;">\[x_1=\frac{\beta }{2}\left ( -\frac{1}{\sqrt{3}}+1 \right );\; x_2=\frac{\beta }{2}\left (\frac{1}{\sqrt{3}}+1 \right )\]</td>
    <td rowspam = "2" align = "right" style = "width: 5%;"><p id = "eq4">(4)</p></td>
  </tr>
   <tr>
    <td align = "left" style = "width: 95%;">\[I_2=\frac{\beta }{2}\left [ 1\left ( \frac{1}{\sqrt{2\pi }}e^{\frac{-\left [\frac{\beta }{2}\left (- \frac{1}{\sqrt{3}}+1 \right )  \right ]^2}{2}} \right )+1\left ( \frac{1}{\sqrt{2\pi }}e^{\frac{-\left [\frac{\beta }{2}\left ( \frac{1}{\sqrt{3}}+1 \right )  \right ]^2}{2}} \right ) \right ]\]</td>
  </tr>
</table>

<p align = "justify">
Desenvolvendo a equação <a href="#eq4">(4)</a> e relacionando-a ao estimador da probabilidade de falha (\(\hat{p}_f\)), tem-se o polinômio apresentando na equação <a href="#eq5">(5)</a>.
</p>

<table border = "0" style = "width: 100%;">
  <tr>
    <td align = "left" style = "width: 95%;">\[\hat{p}_f=0.5-I_2\]</td>
    <td rowspam = "2" align = "right" style = "width: 5%;"><p id = "eq5">(5)</p></td>
  </tr>
   <tr>
    <td align = "left" style = "width: 95%;">\[\hat{p}_f=0.5-\frac{\beta }{2\sqrt{2\pi }}\left ( e^{-\left ( \frac{2-\sqrt{3}}{12} \right )\beta ^2}+e^{-\left ( \frac{2+\sqrt{3}}{12} \right )\beta ^2} \right )\]</td>
  </tr>
</table>

<p align = "justify">
Uma vez que o estimador da probabilidade de falha (\(\hat{p}_f\)) é conhecido, obtido por intermédio da Simulação de Monte Carlo (SMC), o índice de confiabilidade \(β\) será igual à raiz não nula da função representada na equação <a href="#eq6">(6)</a>.
</p>

<table border = "0" style = "width: 100%;">
  <tr>
    <td align = "left" style = "width: 95%;">\[f(\beta )=\frac{\beta }{2\sqrt{2\pi }}\left ( e^{-\left ( \frac{2-\sqrt{3}}{12} \right )\beta ^2}+e^{-\left ( \frac{2+\sqrt{3}}{12} \right )\beta ^2} \right )+\left (\hat{p}_f-0.5  \right )\]</td>
  </tr>
</table>












<p align = "justify" id = "qua33"><b>Quadro 3.3.</b> Operadores lógicos.</p>
<table>
<thead>
  <tr>
    <th>Operador Python</th>
    <th>Função</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><center><code>and</code></center></td>
    <td><p align = "justify">O operador <code>and</code> retorna <b>True</b> se ambas as expressões condicionais forem verdadeiras.Se qualquer uma das expressões for falsa, o resultado será <b>False</b>.</p></td>
  </tr>
  <tr>
    <td><center><code>or</code></center></td>
    <td><p align = "justify">O operador <code>or</code> retorna <b>True</b> se pelo menos uma das expressões condicionais for verdadeira.Se ambas as expressões forem falsas, o resultado será <b>False</b>.</p></td>
  </tr>
  <tr>
    <td><center><code>not</code></center></td>
    <td><p align = "justify">O operador <code>not</code> inverte o valor de uma expressão booleana. Se a expressão for verdadeira, <code>not</code> a tornará falsa, e vice-versa.</p></td>
  </tr>
</tbody>
</table>

<p align = "justify">
Os operadores lógicos e possíveis combinações booleanas podem ser representados por meio do <a href = "#qua34">Quadro 3.4</a>.
</p>

<p align = "justify" id = "qua34"><b>Quadro 3.4.</b> Tabela verdade.</p>
<table>
    <tr>
        <th>p</th>
        <th>q</th>
        <th>p <code>and</code> q</th>
        <th>p <code>or</code> q</th>
    </tr>
    <tr>
        <td>True</td>
        <td>True</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>True</td>
        <td>False</td>
    </tr>
    <tr>
        <td>True</td>
        <td>False</td>
        <td>False</td>
        <td>False</td>
    </tr>
    <tr>
        <td>True</td>
        <td>True</td>
        <td>True</td>
        <td>False</td>
    </tr>
</table>

and
{: .label .label-blue }

```python
# Exemplo 1: Combinação V e F
a = True
b = False
resultado = a and b
print(resultado)

# Exemplo 2: Combinação V e V
a = True
b = True
resultado = a and b
print(resultado)
```
```cmd
False
True
```

or
{: .label .label-blue }

```python
a = True
b = False
resultado = a or b
print(resultado)
```
```cmd
True
```

not
{: .label .label-blue }

```python
a = True
resultado = not a
print(resultado)
```
```cmd
False
```

Exemplo Resolvido 1
{: .label .label-yellow }

<p align = "justify">
    <i>
    Monte diversas sentenças booleanas \(p\) e \(q\) e a partir disso construa a tabela verdade para o operador lógico <code>and</code>.
    </i>
</p>

```python
p = 2 + 2 == 4
q = 2 + 1 == 3
print(f'{p}  and {q}:  ', p and q)
p = 2 + 2 == 8
q = 2 + 1 == 3
print(f'{p} and {q}:  ', p and q)
p = 2 + 2 == 4
q = 2 + 1 == 5
print(f'{p}  and {q}: ', p and q)
p = 2 + 2 == 8
q = 2 + 1 == 5
print(f'{p} and {q}: ', p and q)
```
```cmd
True  and True:   True
False and True:   False
True  and False:  False
False and False:  False
```

Exemplo Resolvido 2
{: .label .label-yellow }

<p align = "justify">
    <i>
    Monte diversas sentenças booleanas \(p\) e \(q\) e a partir disso construa a tabela verdade para o operador lógico <code>or</code>.
    </i>
</p>

```python
p = 2 + 2 == 4
q = 2 + 1 == 3
print(f'{p}  and {q}:  ', p or q)
p = 2 + 2 == 8
q = 2 + 1 == 3
print(f'{p} and {q}:  ', p or q)
p = 2 + 2 == 4
q = 2 + 1 == 5
print(f'{p}  and {q}: ', p or q)
p = 2 + 2 == 8
q = 2 + 1 == 5
print(f'{p} and {q}: ', p or q)
```
```cmd
True  and True:   True
False and True:   True
True  and False:  True
False and False:  False
```
